window.DOMAIN2_QUESTIONS = window.DOMAIN2_QUESTIONS || [];
window.DOMAIN2_QUESTIONS.push({
  "id": "D2-021",
  "domain": 2,
  "task": "2.2",
  "skill": "2.2.3",
  "type": "single",
  "difficulty": "hard",
  "question": "ある企業がカスタマーサポート AI をデプロイしています。一般的な FAQ への回答は小規模モデルで十分ですが、複雑な技術的質問には大規模モデルが必要です。さらに、小規模モデルの出力の信頼度が低い場合にのみ大規模モデルにフォールバックすることでコストを80%削減したいと考えています。この要件を満たす最適なアーキテクチャはどれですか。",
  "options": [
    {
      "id": "A",
      "text": "すべてのリクエストを大規模モデルに送信し、結果をキャッシュして再利用する"
    },
    {
      "id": "B",
      "text": "質問の文字数に基づいてモデルを静的に振り分ける"
    },
    {
      "id": "C",
      "text": "モデルカスケードを構築し、まず小規模モデルで推論を行い、出力の信頼度スコアが閾値を下回った場合のみ大規模モデルにエスカレーションする"
    },
    {
      "id": "D",
      "text": "2つのモデルを並列に実行し、結果を比較して良い方を選択する"
    }
  ],
  "correctAnswers": [
    "C"
  ],
  "explanation": "正解は C です。モデルカスケードは、まず低コストの小規模モデルで処理し、信頼度スコアに基づいて判断が困難なケースのみ高コストの大規模モデルにエスカレーションするパターンです。大部分のリクエストが小規模モデルで処理されるため、大幅なコスト削減が可能です。A はコスト削減目標を達成できません。B は文字数だけでは質問の複雑さを判断できません。D は並列実行では両方のモデルのコストが常にかかります。（スキル2.2.3）",
  "optionExplanations": {
    "A": {
      "correct": false,
      "text": "不正解です。すべてのリクエストを大規模モデルに送信する方法はキャッシュで一部効率化できるものの、コスト削減目標（80%削減）を達成できず、コスト最適化の要件を満たしません。"
    },
    "B": {
      "correct": false,
      "text": "不正解です。文字数による振り分けは実装が簡単であるものの、質問の複雑さを正確に判断できず、適切なモデル選択の要件を満たしません。"
    },
    "C": {
      "correct": true,
      "text": "正解です。モデルカスケードは信頼度ベースのエスカレーションとコスト80%削減の両方を直接満たします。特に大部分のリクエストを小規模モデルで処理することで最小のコストで品質を維持できます。"
    },
    "D": {
      "correct": false,
      "text": "不正解です。2つのモデルの並列実行は品質比較が可能であるものの、両方のコストが常にかかるため、コスト80%削減の要件を満たしません。"
    }
  },
  "references": [
    {
      "title": "Amazon Bedrock inference",
      "url": "https://docs.aws.amazon.com/bedrock/latest/userguide/inference.html"
    },
    {
      "title": "Amazon Bedrock model access",
      "url": "https://docs.aws.amazon.com/bedrock/latest/userguide/model-access.html"
    }
  ]
});
