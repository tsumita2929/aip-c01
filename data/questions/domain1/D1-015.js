window.DOMAIN1_QUESTIONS = window.DOMAIN1_QUESTIONS || [];
window.DOMAIN1_QUESTIONS.push({
  "id": "D1-015",
  "domain": 1,
  "task": "1.2",
  "skill": "1.2.3",
  "type": "single",
  "difficulty": "medium",
  "question": "ある EC サイト企業が、Amazon Bedrock の FM を使用した商品レコメンデーションチャットボットを運用しています。アーキテクチャは API Gateway + Lambda + Bedrock で構成されています。FM プロバイダー側の一時的な障害が月に数回発生し、その間チャットボットがタイムアウトエラーを返してユーザー体験が悪化しています。エラー率が一定の閾値を超えた場合に自動的にフォールバック処理に切り替え、障害が回復したら元のモデルに戻す仕組みを実装する必要があります。最も適切なサーキットブレーカーの実装方法はどれですか？",
  "options": [
    {
      "id": "A",
      "text": "Lambda 関数内で直近のエラー率を DynamoDB に記録し、エラー率が閾値（例: 50%）を超えた場合はサーキットを「オープン」状態にして Bedrock の代わりに DynamoDB に保存された事前計算済みレコメンデーションを返す。一定時間後に「ハーフオープン」状態でテストリクエストを送り、成功すれば「クローズド」に戻す"
    },
    {
      "id": "B",
      "text": "CloudWatch アラームで Bedrock の InvocationClientErrors メトリクスを監視し、閾値超過時に SNS トピック経由で Lambda 関数をトリガーする。Lambda 関数が Route 53 の DNS レコードを更新して、別リージョンの Bedrock エンドポイントにトラフィックを切り替える"
    },
    {
      "id": "C",
      "text": "API Gateway のスロットリング設定でリクエスト量を制限し、WAF のレートベースルールで過剰なリクエストをブロックする。同時に API Gateway のキャッシュを有効にして、障害時にキャッシュされたレスポンスを返す"
    },
    {
      "id": "D",
      "text": "AWS SDK のリトライ設定で最大リトライ回数を10回に設定し、指数バックオフで再試行する。Step Functions のリトライポリシーを組み合わせて、Lambda 関数のタイムアウト後に自動的に再実行する"
    }
  ],
  "correctAnswers": [
    "A"
  ],
  "explanation": "サーキットブレーカーパターンでは、エラー率を監視し、閾値超過時にリクエストを遮断（サーキットオープン）してフォールバック応答を返し、一定時間後にテストリクエスト（ハーフオープン）で回復を確認します。Lambda + DynamoDB でエラー率を追跡し、状態遷移（クローズド→オープン→ハーフオープン→クローズド）を管理する方法がサーキットブレーカーの定義に最も合致します。CloudWatch + SNS + Route 53（B）は障害検知から DNS 更新までに数分のレイテンシーが発生し、DNS の TTL 期間中はクライアントが古いエンドポイントにアクセスし続けるため、即時のフォールバックには不向きです。またこれはサーキットブレーカーではなくフェイルオーバーパターンです。API Gateway スロットリング + WAF（C）はリクエスト制限であり、バックエンド（Bedrock）の障害に基づく動的な遮断とフォールバックの機能はありません。API Gateway キャッシュも、生成AIの動的なレコメンデーションに対してはキャッシュヒット率が低くなります。SDK リトライ + Step Functions リトライ（D）は障害時にさらに多くのリクエストを送信し、障害を悪化させるカスケード障害のリスクがあります。サーキットブレーカーの目的はリクエストを遮断することであり、リトライとは逆のアプローチです。（スキル1.2.3）",
  "optionExplanations": {
    "A": {
      "correct": true,
      "text": "正解です。DynamoDB でエラー率を追跡し、クローズド→オープン→ハーフオープン→クローズドの状態遷移を管理する方法は、サーキットブレーカーパターンの3つの状態（閉・開・半開）を正確に実装しています。事前計算済みレコメンデーションへのフォールバックにより、障害時もユーザーに有用な応答を返せます。"
    },
    "B": {
      "correct": false,
      "text": "不正解です。CloudWatch アラーム + SNS + Route 53 DNS 更新は障害検知と切り替えを実現できますが、DNS 更新のレイテンシー（数分）と TTL 期間中の古いエンドポイントへのアクセスがあり、即時のフォールバックには不向きです。またこれはフェイルオーバーパターンであり、サーキットブレーカーの状態遷移（オープン→ハーフオープン→クローズド）の仕組みがありません。"
    },
    "C": {
      "correct": false,
      "text": "不正解です。API Gateway のスロットリングはリクエスト量の制限であり、バックエンドの障害率に基づく動的な遮断ではありません。API Gateway キャッシュは同一リクエストに対するレスポンスをキャッシュしますが、レコメンデーションはユーザーごとに異なるためキャッシュヒット率が低く、有効なフォールバックになりません。"
    },
    "D": {
      "correct": false,
      "text": "不正解です。リトライ回数を増やすと障害中のバックエンドにさらに多くのリクエストが送信され、障害の回復を遅らせるカスケード障害を引き起こすリスクがあります。サーキットブレーカーの目的は障害時にリクエストを遮断してバックエンドを保護することであり、過剰なリトライは逆効果です。"
    }
  },
  "references": [
    {
      "title": "Amazon Bedrock の推論",
      "url": "https://docs.aws.amazon.com/bedrock/latest/userguide/inference.html"
    },
    {
      "title": "AWS Well-Architected Framework - 信頼性の柱",
      "url": "https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/welcome.html"
    }
  ]
});
