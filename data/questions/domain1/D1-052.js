window.DOMAIN1_QUESTIONS = window.DOMAIN1_QUESTIONS || [];
window.DOMAIN1_QUESTIONS.push({
  "id": "D1-052",
  "domain": 1,
  "task": "1.5",
  "skill": "1.5.6",
  "type": "single",
  "difficulty": "medium",
  "question": "ある開発チームが、Amazon Bedrock Agents を使用して、顧客対応AIエージェントを構築しています。エージェントは社内データベース検索、CRM システム（Salesforce）、在庫管理API、ナレッジベース検索の4つの外部ツールを使用します。現在、四半期ごとに新しいツール（配送状況追跡API等）の追加や既存ツールのAPI仕様変更が発生しています。要件として、(1) FM がユーザーの質問に応じてどのツールを呼び出すかを動的に判断できること、(2) ツールの追加・変更時のエージェント側の修正工数を最小化すること、(3) ツールのAPIスキーマやパラメータの変更を一元管理できること、が求められています。最も適切なアーキテクチャはどれですか？",
  "options": [
    {
      "id": "A",
      "text": "Bedrock Agents のアクショングループで各ツールを OpenAPI スキーマで定義し、Lambda 関数経由で外部API を呼び出す。OpenAPI スキーマにツールの目的・パラメータ・応答形式を詳細に記述することで、FM がスキーマの記述に基づいて呼び出すツールを自律的に判断する。新規ツール追加時はアクショングループの追加のみで対応する"
    },
    {
      "id": "B",
      "text": "Bedrock Agents に4つのナレッジベースを接続し、各ナレッジベースに対応するツールのAPI仕様書とサンプルリクエスト/レスポンスをドキュメントとして格納する。FM がナレッジベースからAPI仕様を検索し、アプリケーション層のLambda関数でAPIを呼び出す"
    },
    {
      "id": "C",
      "text": "Step Functions のワークフローで4つのツール呼び出しをParallel ステートで並列実行し、すべてのツールの結果を集約して Bedrock FM に送信する。FM が全結果から質問に関連する情報を抽出して回答を生成する。新規ツール追加時はワークフロー定義にステートを追加する"
    },
    {
      "id": "D",
      "text": "各ツールのAPI呼び出し方法をシステムプロンプトに自然言語で記述し、Bedrock Converse API の toolUse 機能でFMにツール選択と呼び出しパラメータの生成を任せる。アプリケーション層で FM が返したツール呼び出しリクエストを解析し、対応するAPIを実行して結果を FM に返す"
    }
  ],
  "correctAnswers": [
    "A"
  ],
  "explanation": "Bedrock Agents のアクショングループは、各ツールを OpenAPI スキーマで定義し、FM がスキーマの記述（ツールの目的、パラメータ、応答形式）に基づいて呼び出すツールを自律的に判断する機能を提供します。新規ツールの追加はアクショングループの追加（OpenAPI スキーマ + Lambda 関数）のみで対応でき、既存のエージェント設定やプロンプトの変更は不要です。API仕様の変更もOpenAPIスキーマの更新で一元管理できます。ナレッジベースにAPI仕様を格納（B）する方法は、FM がAPI仕様を検索・理解してパラメータを構成することを期待しますが、ナレッジベースはドキュメント検索用であり、構造化されたAPIスキーマの解釈と正確なパラメータ生成には適していません。アクショングループの OpenAPI スキーマは FM がネイティブに解釈できる形式でツールを定義します。Step Functions の並列実行（C）はすべてのツールを常に呼び出すため、不要なAPI呼び出しが発生しコストとレイテンシーが増加します。また、FM がどのツールを呼び出すかを動的に判断する要件を満たせず、新規ツール追加時にワークフロー定義の変更とデプロイが必要です。Converse API の toolUse（D）はFMによるツール選択が可能ですが、ツール定義がプロンプト内の自然言語記述に依存するため、OpenAPIスキーマと比較してパラメータの型・制約の定義が曖昧になります。また、API呼び出しの実行ロジックをアプリケーション層でカスタム実装する必要があり、Bedrock Agents のマネージドなオーケストレーションと比較して管理負荷が増加します。（スキル1.5.6）",
  "optionExplanations": {
    "A": {
      "correct": true,
      "text": "正解です。Bedrock Agents のアクショングループは OpenAPI スキーマでツールを定義し、FM の自律的なツール選択、アクショングループ追加のみでの新規ツール対応、OpenAPIスキーマによるAPI仕様の一元管理の要件をすべて直接満たします。"
    },
    "B": {
      "correct": false,
      "text": "不正解です。ナレッジベースはドキュメント検索用であり、構造化されたAPIスキーマの解釈と正確なパラメータ生成には適していません。FM がRAG検索結果からAPI仕様を正確に理解してパラメータを構成する信頼性は、OpenAPIスキーマのネイティブ解釈と比較して低く、ツール統合の管理も煩雑になります。"
    },
    "C": {
      "correct": false,
      "text": "不正解です。すべてのツールを並列に呼び出すアーキテクチャでは、質問に無関係なAPIも呼び出されてコストとレイテンシーが増加します。FM がどのツールを呼び出すかを動的に判断する要件を満たせず、新規ツール追加時にワークフロー定義の変更・再デプロイが必要です。"
    },
    "D": {
      "correct": false,
      "text": "不正解です。Converse API の toolUse はFMによるツール選択が可能ですが、ツール定義が自然言語に依存してパラメータの型・制約の定義が曖昧になり、API呼び出しのアプリケーション層実装が必要です。Bedrock Agents のマネージドオーケストレーションと比較して管理負荷が増加します。"
    }
  },
  "references": [
    {
      "title": "Amazon Bedrock Agents",
      "url": "https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html"
    }
  ]
});
